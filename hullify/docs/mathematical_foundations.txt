This text describes the creation of the bounding planes for convex hulls as of 7/16/2014

Basic Idea:
	mesh_bound.cpp defines a class that will convert a given pointcloud and centroid (center of mass) into bounding planes to limit grasping attempts. The old method was to simply define a single plane running through the calculated centroid of the object with a normal vector going from the centroid to the camera that recorded the points. From there, the points were projected onto the plane; the most distal point marked the boundary of a representative polygon and this was published.
	The new idea is to create two bounding polygons that also include the centroid, but have normals that may point in different directions than the original single plane's normal. The intersection of these planes then defines a line that limits them with respect to each other.
	Imagine staring at an object. Suppose then that your two eyes were points and along with the center of the object; these three points then define a plane (let it be called the horizontal plane). Project the collected pointcloud that represents said object onto this plane. Next, assume a bird's eye view of this plane, looking straight down at it from above. Define a line between one arbitrary point and the centroid as a reference line (ref). Then, measure and record the angle between each point and the reference line.
	Find the largest consecutive, radial change in angle and presume that these points limit your understanding of the object; these will help form the bounding plane. The centroid is each of these two planes, but the question is, what are their normals? Well, the normals of these planes are orthogonal to both the normal of the horizontal plane and the vectors between the centroid and these two points; thus, crossing the above vectors will yield appropriate normals for the bounding planes. The task is then presentation.
	The actual algorithm has more safety checks than those listed here, but this is a good outline.

Important Notes:
	The plane equation is now and will forever be ax + by + cz + d = 0 where <a, b, c> is the normal vector of the plane and (x, y, z) is an arbitrary point on the plane.

The Math:

The only truly difficult math (if you have a good mental picture of the situation) is for calculating the radial angle of each point projected onto the horizontal plane, and even that is not terribly hard. Since arccosine can only give back angles between 0 and PI radians, we must determine if the point is "already a half circle around". We can do this easily by letting the reference line cut the plane into two sections, one is arbitrarily 0 to PI, and the other is PI to 2PI. The actual choice has no bearing so long as the algorithm is consistent. The following describes these above/below line calculations.
	 The line equation for the reference line uses as slope the vector between the centroid and the reference point, and uses the centroid itself as the initial point.

	centroid = <x0, y0, z0>    slope = <a, b, c>
	Define, then, a vector orthogonal to this line by crossing the line vector with the normal of the horizontal plane
	line_normal = plane_normal x slope = <w, u, v>;
	
	To simplify calculations, both the line_normal and the slope are changed to unit vectors by dividing by their length (normalizing)

	To determine if a point is above/below the reference line, all we must do is find a scalar s, such that s times line_normal vector will project the point in question (x, y, z) onto the reference line at some point t*slope away from the centroid, where t is another scalar.

	So, simply set s*line_normal + pt = t*slope + centroid.
	This yields three equations relating x1 = x2, y1 = y2, and z1 = z2.

	Solving the first equation for s yields:
		s*w + x = t*a + x0
		s = (t*a + x0 - x) / w

	Solving the second equation for t yields:
		s*u + y = t*b + y0
		t = (t*b + y0 - y) / u

	Substituting the first equation into the second yields (algebra abridged):
		t = ( u(x - x0) - w(y - y0) ) / (a*u - b*y)

	s can then be easily solved for.
	If s > 0, then the point is above the line. If s < 0, the point is define as below the line.
	** The above code is in MeshBound::big_angle()


The other spotty bit of math is generating the normal vector for the horizontal plane:
	The simplest way I thought to do it was to first define k = <0, 0, 1> and to define a plane using the centroid and the vector between the robot's camera and the centroid (camera_normal). Then, find the angle between k and the camera angle using a dot product (cannot be larger than PI radians) and subtract PI/2 radians from it. This angle measure then defines the angle past k that the horizontal plane's normal should be at in this plane.
	BUT... That's difficult and odd. What I did instead, was to cross k (from above) with the vector from the camera to the centroid. This gives the normal of the plane containing the two vectors (let it be called h). We know that the horizontal plane's normal must be orthogonal to this vector because it too is in the same plane as k adn the camera normal. But, we also know it is orthogonal to the camera to centroid vector because said vector is in the horizontal plane. Thus crossing h and the camera to centroid vectors gives us the horizontal plane normal.
